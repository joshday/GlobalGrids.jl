[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GlobalGrids.jl",
    "section": "",
    "text": "1 Intro to GlobalGrids.jl\nDiscrete global grids (DGGs) for Julia.\nGlobalGrids provides:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Intro to GlobalGrids.jl</span>"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "GlobalGrids.jl",
    "section": "1.1 Installation",
    "text": "1.1 Installation\nusing Pkg\nPkg.add(url = \"https://github.com/joshday/GlobalGrids.jl\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Intro to GlobalGrids.jl</span>"
    ]
  },
  {
    "objectID": "index.html#quickstart",
    "href": "index.html#quickstart",
    "title": "GlobalGrids.jl",
    "section": "1.2 Quickstart",
    "text": "1.2 Quickstart\n\nimport GlobalGrids as GG\nusing CairoMakie\n\n# Create a lon/lat point\np = GG.LonLat(-75.0, 54.0)\n\n# Find the cell containing the point at a given resolution\nc = GG.H3Cell(p, 7)\n\n\n  ⬡ H3Cell 7 7-1203346\n\n\n\n\npoly(GG.grid_ring(c, 1), color=1:6)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Intro to GlobalGrids.jl</span>"
    ]
  },
  {
    "objectID": "h3.html",
    "href": "h3.html",
    "title": "2  H3 Grid System",
    "section": "",
    "text": "2.1 Creating an H3Cell\nH3 is a DGGS developed by Uber. Here’s a brief summary of the H3 grid system:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>H3 Grid System</span>"
    ]
  },
  {
    "objectID": "h3.html#creating-an-h3cell",
    "href": "h3.html#creating-an-h3cell",
    "title": "2  H3 Grid System",
    "section": "",
    "text": "Every cell in the grid is indexed by a single UInt64. An H3Cell is simply a wrapper around a UInt64 index.\nThe index encodes the base cell (121 possible values, shown in the figure above), resolution, and digits (0-6).\nEach hexagon gets split into 7 hexagons by the next highest resolution. An additional digit corresponds to one of the smaller hexagons derived from its parent.\n\n\n2.1.1 From H3Grid\n\ngrid = H3Grid()\n\n# Select one of the 121 base cells:\ngrid[121]\n\n\n  ⬡ H3Cell 0 121-\n\n\n\n\n# Nesting getindex to dive down the hierarchy:\ngrid[121][1][5][0]\n\n\n  ⬡ H3Cell 3 121-150\n\n\n\n\n\n2.1.2 From Base Cell and Digits\n\nH3Cell(121, [1, 5, 0])\n\n\n  ⬡ H3Cell 3 121-150\n\n\n\n\n\n2.1.3 From Coordinates and Resolution:\n\ncoords = LonLat(-75.0, 54.0)\n\nH3Cell(coords, 10)\n\n\n  ⬡ H3Cell 10 7-1203346514\n\n\n\n\n\n2.1.4 From Hexadecimal String\n\nc = H3Cell(coords)\n\nstr = GlobalGrids.h3_string(c)\n@info str\n\nH3Cell(str)\n\n\n[ Info: 8a0e506e6a67fff\n\n\n\n\n\n  ⬡ H3Cell 10 7-1203346514",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>H3 Grid System</span>"
    ]
  },
  {
    "objectID": "h3.html#inspecting-h3cells",
    "href": "h3.html#inspecting-h3cells",
    "title": "2  H3 Grid System",
    "section": "2.2 Inspecting H3Cells",
    "text": "2.2 Inspecting H3Cells\n\n\nCode\n@show GlobalGrids.resolution(c)\n@show GlobalGrids.h3_base_cell(c)\n@show GlobalGrids.is_pentagon(c)\n@show GlobalGrids.h3_digits(c)\n@show GlobalGrids.h3_face_numbers(c)\nnothing\n\n\nGlobalGrids.resolution(c) = 10\nGlobalGrids.h3_base_cell(c) = 7\nGlobalGrids.is_pentagon(c) = false\nGlobalGrids.h3_digits(c) = [1, 2, 0, 3, 3, 4, 6, 5, 1, 4]\nGlobalGrids.h3_face_numbers(c) = Int32[2]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>H3 Grid System</span>"
    ]
  },
  {
    "objectID": "h3.html#geointerface-integration",
    "href": "h3.html#geointerface-integration",
    "title": "2  H3 Grid System",
    "section": "2.3 GeoInterface Integration:",
    "text": "2.3 GeoInterface Integration:\n\n\nCode\nimport GeoInterface as GI\n\n@show GI.coordinates(c)\n@show GI.centroid(c)\n@show GI.area(c)  # meters ^ 2\nnothing\n\n\nGI.coordinates(c) = GlobalGrids.LonLat{Float64}[LonLat{Float64} (-74.99962251383738, 54.0001926668228), LonLat{Float64} (-75.0008585102879, 54.0000194052262), LonLat{Float64} (-75.00122192991167, 53.999307797036366), LonLat{Float64} (-75.00034938834023, 53.99876945809693), LonLat{Float64} (-74.99911343000446, 53.99894271390214), LonLat{Float64} (-74.99874997512619, 53.99965431443802), LonLat{Float64} (-74.99962251383738, 54.0001926668228)]\nGI.centroid(c) = LonLat{Float64} (-74.99998595778595, 53.99948106205936)\nGI.area(c) = 17803.420253871413",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>H3 Grid System</span>"
    ]
  },
  {
    "objectID": "h3.html#grid-hierarchy",
    "href": "h3.html#grid-hierarchy",
    "title": "2  H3 Grid System",
    "section": "2.4 Grid Hierarchy",
    "text": "2.4 Grid Hierarchy\n\nparent, siblings, and children\n\n\n\nCode\nfig = Figure()\nax = Axis(fig[1,1], title=\"Cell:Black, Parent:Blue, Siblings:Orange, Children:Green\")\nlines!(ax, GlobalGrids.parent(c), color = :blue)\npoly!(ax, c, color = :black)\nlines!(ax, GlobalGrids.siblings(c), color = :orange)\nlines!(ax, GlobalGrids.children(c), color = :green)\nfig",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>H3 Grid System</span>"
    ]
  },
  {
    "objectID": "h3.html#rings-and-disks",
    "href": "h3.html#rings-and-disks",
    "title": "2  H3 Grid System",
    "section": "2.5 Rings and Disks",
    "text": "2.5 Rings and Disks\n\ngrid_ring(cell, i) returns the cells that are exactly grid distance i away from the cell.\ngrid_disk(cell, i) is similar to grid_ring, but returns all cells inside the ring as well.\n\n\n\nCode\nfig = Figure()\nax = Axis(fig[1,1])\ncolors = [:blue, :green, :red, :magenta]\n\npoly!(ax, c, color=:black)\nfor i in 1:4\n    poly!(ax, GlobalGrids.grid_ring(c, i), color=colors[i])\nend\n\n\nfig",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>H3 Grid System</span>"
    ]
  },
  {
    "objectID": "h3.html#rasterizing-geometries-to-the-h3-grid",
    "href": "h3.html#rasterizing-geometries-to-the-h3-grid",
    "title": "2  H3 Grid System",
    "section": "2.6 “Rasterizing” Geometries to the H3 Grid",
    "text": "2.6 “Rasterizing” Geometries to the H3 Grid\n\n2.6.1 Point\n\n\nCode\nll = LonLat(-54.0, -12.0)\n\nfig = Figure()\nax = Axis(fig[1,1], title=\"Cells Containing Point at Resolutions 0-3\")\nfor res in 0:3\n    lines!(ax, h3cells(ll, res))\nend\nscatter!(ax, ll)\n\nfig\n\n\n\n\n\n\n\n2.6.2 MultiPoint\n\n\nCode\ncoords = [LonLat(360rand() - 180, 180rand() - 90) for _ in 1:100]\n\nx = H3Cell.(coords, 0)\n\nf, a, p = lines(x, axis=(;type=GeoAxis, dest = \"+proj=ortho +lon_0=-50 +lat_0=30\"))\nscatter!(a, coords, color=:black)\nf\n\n\n\n\n\n\n\n2.6.3 Line\n\nBy default, the cells will be an arbitrary shortest path between the cells that contain the two points (containment = :shortest_path).\nThe other containment options for line(string)s are :overlap and :overlap_bbox.\n\n\n\nCode\nline = GI.Line([LonLat(0, 0), LonLat(1,1)])\n\nfig = Figure(size=(1000, 300))\n\nfor (i, containment) in enumerate((:shortest_path, :overlap, :overlap_bbox))\n    ax = Axis(fig[1, i], aspect=DataAspect(), title=\"containment = :$containment\")\n    x = h3cells(line, 6; containment)\n    lines!(ax, x)\n    lines!(ax, GI.coordinates(line), linewidth=3, color = :black)\nend\n\nfig\n\n\n\n\n\n\n\n2.6.4 (Multi)Polygon\n\nContainment modes for polygons:\n\n:center: Include cell if its center is inside the polygon.\n:full: Include cell if all vertices are inside the polygon.\n:overlap: Include cell if any part intersects the polygon.\n:overlap_bbox: Include cell if any part of the bounding box intersects the polygon.\n\n\n\n\nCode\nusing OSMGeocoder\n\nobj = geocode(state=\"North Carolina\")\n\n# Create figure\nfunction make_axis(i, j, containment)\n    ax = Axis(fig[i, j], title=\"containment = :$containment\")\n    x = h3cells(obj.geometry[1], 4; containment)\n    lines!(ax, x)\n    lines!(ax, obj.geometry)\nend\nfig = Figure()\nmake_axis(1, 1, :center)\nmake_axis(1, 2, :full)\nmake_axis(2, 1, :overlap)\nmake_axis(2, 2, :overlap_bbox)\nfig\n\n\n\n\n\n\n\n2.6.5 Extents\n\n\n\n\n\n\nNote\n\n\n\nThe same containment options for (multi)polygons are available for Extents. test\n\n\n\n\nCode\nex = GI.extent(obj)\n\n# for plotting\nx1, x2 = ex.X\ny1, y2 = ex.Y\nlinestring = GI.LineString([(x1,y1), (x1,y2), (x2,y2), (x2, y1), (x1,y1)])\n\n# Create figure\nfunction make_axis(i, j, containment)\n    ax = Axis(fig[i, j], title=\"containment = :$containment\")\n    x = h3cells(ex, 4; containment)\n    lines!(ax, linestring)\n    lines!(ax, x)\nend\nfig = Figure()\nmake_axis(1, 1, :center)\nmake_axis(1, 2, :full)\nmake_axis(2, 1, :overlap)\nmake_axis(2, 2, :overlap_bbox)\nfig",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>H3 Grid System</span>"
    ]
  },
  {
    "objectID": "h3.html#rasterizing-rasters",
    "href": "h3.html#rasterizing-rasters",
    "title": "2  H3 Grid System",
    "section": "2.7 “Rasterizing” Rasters",
    "text": "2.7 “Rasterizing” Rasters\n\nFor data that is associated with a location, i.e. rasters, use h3join(data, resolution) to create a Dict{H3Cell, Vector{T}} where T is the eltype of the data.\nNote that plotting polygons across a left/right boundary on a given projection can have strange behavior. See https://en.wikipedia.org/wiki/180th_meridian#Software_representation_problems.\n\n\n\nCode\nimport Scratch\nENV[\"RASTERDATASOURCES_PATH\"] = Scratch.get_scratch!(\"RASTERDATASOURCES_PATH\")\nnothing\n\n\n\n\nCode\nusing GlobalGrids, Rasters, RasterDataSources, ArchGDAL\n\nr = Raster(getraster(WorldClim{Elevation}).elev)\n\ndict = h3join(r, 2)\n\ncells = collect(keys(dict))\nvals = maximum.(values(dict))\n\n# Do some work to avoid polygon issues on boundaries:\nidx = findall(x -&gt; !GlobalGrids.crosses_meridian(x, 180), cells)\n\ncells2 = cells[idx]\nvals2 = vals[idx]\n\nfig = Figure()\nax1 = Axis(fig[1, 1], title=\"Without Polygon Filtering\")\nax2 = Axis(fig[2, 1], title=\"With Polygon Filtering\")\n\npoly!(ax1, cells, color=vals)\npoly!(ax2, cells2, color=vals2)\nfig\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nWhen plotting large numbers of cells, its more efficient to just plot the centroid of the cell:\n\n\n\n\nCode\ndict = h3join(r, 4)\n\ncells = collect(keys(dict))\n\nvals = maximum.(values(dict))\n\nscatter(GI.centroid.(cells), color=vals, markersize=2)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>H3 Grid System</span>"
    ]
  }
]